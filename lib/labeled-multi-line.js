// Generated by CoffeeScript 1.8.0
var Chart, EL_PADDING, LabeledMultiLineChart, React, add, d3, sum,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

React = require('react');

d3 = require('d3');

Chart = require('./chart');

add = function(a, b) {
  return a + b;
};

sum = function(numbers) {
  return numbers.reduce(add, 0);
};

EL_PADDING = 10;

module.exports = LabeledMultiLineChart = (function(_super) {
  __extends(LabeledMultiLineChart, _super);

  function LabeledMultiLineChart() {
    return LabeledMultiLineChart.__super__.constructor.apply(this, arguments);
  }

  LabeledMultiLineChart.prototype.buildSeries = function() {
    var all_series, cell_width, colors, data, _ref;
    _ref = this.props, data = _ref.data, colors = _ref.colors;
    all_series = {};
    cell_width = this.computeCellWidth();
    data.forEach(function(d, di) {
      if (d.values != null) {
        return Object.keys(d.values).map(function(series_key) {
          all_series[series_key] || (all_series[series_key] = []);
          return all_series[series_key].push({
            x: cell_width * (di + 0.5),
            y: d.values[series_key]
          });
        });
      }
    });
    return Object.keys(all_series).map(function(series_key) {
      series_key;
      return {
        color: colors != null ? colors[series_key] : void 0,
        data: all_series[series_key]
      };
    });
  };

  LabeledMultiLineChart.prototype.chartHeight = function() {
    var height, label_height, max_label_length, rotate, _ref, _ref1, _ref2;
    if (rotate = (_ref = this.props.x_axis) != null ? _ref.rotate : void 0) {
      max_label_length = 0;
      this.props.data.forEach(function(d) {
        var _ref1;
        if ((d != null ? (_ref1 = d.label) != null ? _ref1.length : void 0 : void 0) > max_label_length) {
          return max_label_length = d.label.length;
        }
      });
      label_height = max_label_length * 6.5 * Math.sin(Math.PI * Math.abs(rotate) / 180);
    } else {
      label_height = 8;
    }
    height = this.props.height + (((_ref1 = this.props) != null ? (_ref2 = _ref1.options) != null ? _ref2.el_padding : void 0 : void 0) || 0) + 15 + label_height;
    return height;
  };

  LabeledMultiLineChart.prototype.computeCellWidth = function() {
    var data, height, horizontal, num_bars, options, width, _ref;
    _ref = this.props, width = _ref.width, height = _ref.height, data = _ref.data, options = _ref.options;
    horizontal = options.horizontal;
    num_bars = data.length;
    if (horizontal) {
      return Math.floor(height / num_bars - 1);
    } else {
      return Math.floor(width / num_bars - 1);
    }
  };

  LabeledMultiLineChart.prototype.renderChart = function() {
    var all_series, bar_padding, cell_index, cell_width, chart_height, colorer, colors, curve, data, el_padding, fill, height, horizontal, line, markers, options, rotate_labels, stroke_width, total_ys, width, x, x_extent, y, y_extent, _ref, _ref1, _ref2;
    _ref = this.props, width = _ref.width, height = _ref.height, data = _ref.data, x = _ref.x, y = _ref.y, colors = _ref.colors, curve = _ref.curve, fill = _ref.fill, options = _ref.options, markers = _ref.markers, colorer = _ref.colorer;
    _ref1 = this.state, x = _ref1.x, y = _ref1.y;
    bar_padding = options.bar_padding, stroke_width = options.stroke_width, horizontal = options.horizontal, el_padding = options.el_padding;
    bar_padding || (bar_padding = 10);
    el_padding || (el_padding = EL_PADDING);
    rotate_labels = (_ref2 = this.props.x_axis) != null ? _ref2.rotate : void 0;
    cell_width = this.computeCellWidth.bind(this)();
    x_extent = d3.extent([0, width]);
    total_ys = data.map(function(d) {
      return sum(Object.keys(d.values).map(function(k) {
        return d.values[k];
      }));
    });
    y_extent = Math.max.apply(Math, total_ys);
    y = d3.scaleLinear().domain([0, y_extent]).range([0, height]);
    all_series = this.buildSeries.bind(this)();
    line = d3.line().curve(curve ? d3.curveMonotoneX : d3.curveLinear).x(function(d) {
      return d.x;
    }).y(function(d) {
      return height - y(d.y);
    });
    if (horizontal) {
      line = d3.line().curve(curve ? d3.curveMonotoneX : d3.curveLinear).x(function(d) {
        return x(d.x);
      }).y(function(d) {
        return d.y;
      });
    }
    cell_index = -1;
    chart_height = height + 4 * bar_padding;
    cell_index = 0;
    return React.createElement("svg", {
      "className": 'line-chart',
      "style": {
        width: width,
        height: chart_height
      },
      "width": width,
      "height": chart_height
    }, all_series.map((function(_this) {
      return function(series, di) {
        var d, da, first_point, last_point;
        d = line(series.data);
        return React.createElement("g", {
          "key": di
        }, (fill ? (first_point = {
          x: x.domain()[0],
          y: y.domain()[0]
        }, last_point = {
          x: x.domain()[1],
          y: y.domain()[0]
        }, da = line([first_point].concat(data).concat([last_point])), React.createElement("path", {
          "d": da,
          "fill": series.color || "#333",
          "opacity": 0.2,
          "stroke": 'none'
        })) : void 0), React.createElement("path", {
          "d": d,
          "fill": "none",
          "stroke": series.color || "#333",
          "strokeWidth": stroke_width
        }));
      };
    })(this)), data.map((function(_this) {
      return function(d, i_data) {
        var l, label_height, label_x, label_x_tmp, label_y, label_y_tmp, text_anchor, total_y;
        cell_index++;
        total_y = 0;
        return React.createElement("g", {
          "className": 'bar',
          "key": i_data
        }, (l = d.label, label_height = 8, label_x = cell_width * (i_data + 0.5), label_y = height + 15 + el_padding, rotate_labels > 0 ? (text_anchor = 'start', label_x -= label_height / 2) : rotate_labels < 0 ? (text_anchor = 'end', label_x += label_height / 2) : text_anchor = 'middle', horizontal ? (label_y_tmp = label_y, label_x_tmp = label_x, label_x = 0, label_y = label_x_tmp) : void 0, React.createElement("text", {
          "className": 'label',
          "y": label_y,
          "x": label_x,
          "text-anchor": text_anchor,
          "width": cell_width,
          "transform": "rotate(" + rotate_labels + "," + label_x + "," + label_y + ")"
        }, l)));
      };
    })(this)));
  };

  return LabeledMultiLineChart;

})(Chart);
