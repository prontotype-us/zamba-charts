// Generated by CoffeeScript 1.8.0
var EPSILON, Histogram, React, StackedBarChart, d3, get, groupBy, helpers, sortBy,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

React = require('preact');

d3 = require('d3');

StackedBarChart = require('./stacked-bar');

helpers = require('./helpers');

EPSILON = 0.001;

get = function(key, from) {
  if (typeof key === 'function') {
    return key(from);
  } else {
    return from[key];
  }
};

sortBy = function(key, list) {
  return list.sort(function(a, b) {
    if (get(key, a) > get(key, b)) {
      return 1;
    } else if (get(key, a) < get(key, b)) {
      return -1;
    } else {
      return 0;
    }
  });
};

groupBy = function(key, list) {
  var grouped, item, value, _i, _len;
  grouped = {};
  sortBy(key, list);
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    item = list[_i];
    value = get(key, item);
    grouped[value] || (grouped[value] = []);
    grouped[value].push(item);
  }
  return grouped;
};

module.exports = Histogram = (function(_super) {
  __extends(Histogram, _super);

  function Histogram() {
    return Histogram.__super__.constructor.apply(this, arguments);
  }

  Histogram.prototype.getDefaultProps = function() {
    return {
      width: 100,
      height: 100,
      padding: 0,
      x_axis: {},
      y_axis: {}
    };
  };

  Histogram.prototype.binData = function() {
    var bin_key, bin_size, bins, data, group, group_key, group_value, grouped, in_edge_bin, item, max, min, n_bins, pointInRange, x_extent, _base, _i, _j, _len, _ref, _results;
    _ref = this.props, data = _ref.data, bin_key = _ref.bin_key, min = _ref.min, max = _ref.max, n_bins = _ref.n_bins, bin_size = _ref.bin_size, group_key = _ref.group_key;
    x_extent = d3.extent(data, function(d) {
      return d.x;
    });
    if (min != null) {
      x_extent[0] = min;
    } else {
      min = x_extent[0];
    }
    if (max != null) {
      x_extent[1] = max;
    } else {
      max = x_extent[1];
    }
    if (bin_size != null) {
      n_bins = Math.ceil((max - min) / bin_size);
    } else {
      n_bins || (n_bins = 10);
      bin_size = (max - min) / n_bins;
    }
    pointInRange = function(min, max) {
      return function(d) {
        var point;
        if (bin_key != null) {
          point = d[bin_key];
        } else {
          point = d;
        }
        return (point.x >= min) && (point.x < max);
      };
    };
    bins = (function() {
      _results = [];
      for (var _i = 0; 0 <= n_bins ? _i < n_bins : _i > n_bins; 0 <= n_bins ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(bi) {
      var b_max, b_min, grouped, in_this_bin;
      b_min = min + (bi * bin_size);
      b_max = min + ((bi + 1) * bin_size);
      in_this_bin = data.filter(pointInRange(b_min, b_max));
      grouped = groupBy(group_key, in_this_bin);
      return {
        x0: b_min,
        x: b_min,
        x1: b_max,
        grouped: grouped
      };
    });
    in_edge_bin = data.filter(pointInRange(max, max + EPSILON));
    grouped = groupBy(group_key, in_edge_bin);
    for (group_value in grouped) {
      group = grouped[group_value];
      for (_j = 0, _len = group.length; _j < _len; _j++) {
        item = group[_j];
        (_base = bins[n_bins - 1].grouped)[group_value] || (_base[group_value] = []);
        bins[n_bins - 1].grouped[group_value].push(item);
      }
    }
    return [bins, x_extent, n_bins];
  };

  Histogram.prototype.render = function() {
    var axis_size, bin, bins, color, data, data_by_group, datas, group, group_value, height, n_bins, onClick, padding, r, title, total, width, x, x_axis, x_extent, y, y_axis, y_max, _i, _len, _ref, _ref1, _ref2;
    _ref = this.props, width = _ref.width, height = _ref.height, padding = _ref.padding, data = _ref.data, x = _ref.x, y = _ref.y, r = _ref.r, axis_size = _ref.axis_size, title = _ref.title, x_axis = _ref.x_axis, y_axis = _ref.y_axis, color = _ref.color, onClick = _ref.onClick;
    padding = helpers.transformPadding(padding);
    _ref1 = this.binData(), bins = _ref1[0], x_extent = _ref1[1], n_bins = _ref1[2];
    data_by_group = {};
    y_max = 0;
    for (_i = 0, _len = bins.length; _i < _len; _i++) {
      bin = bins[_i];
      total = 0;
      _ref2 = bin.grouped;
      for (group_value in _ref2) {
        group = _ref2[group_value];
        data_by_group[group_value] || (data_by_group[group_value] = []);
        group.y0 = total;
        group.y = group.length;
        group.y1 = group.y0 + group.y;
        total += group.y;
        data_by_group[group_value].push({
          x: bin.x,
          x0: bin.x0,
          x1: bin.x1,
          y0: group.y0,
          y1: group.y1
        });
      }
      if (total > y_max) {
        y_max = total;
      }
    }
    datas = [];
    for (group_value in data_by_group) {
      data = data_by_group[group_value];
      data.key = group_value;
      datas.push(data);
    }
    x_axis.ticks || (x_axis.ticks = n_bins);
    x = d3.scaleLinear().domain(x_extent).range([padding.left, width - padding.right]);
    y = d3.scaleLinear().domain([0, y_max]).range([height - padding.bottom, padding.top]);
    return React.createElement(StackedBarChart, React.__spread({}, this.props, {
      "data": bins,
      "x": x,
      "y": y,
      "bar_width": (width - padding.left - padding.right) / n_bins - 1
    }));
  };

  return Histogram;

})(React.Component);
