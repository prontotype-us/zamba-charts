// Generated by CoffeeScript 1.10.0
var EPSILON, Histogram, React, StackedBarChart, d3, get, groupBy, helpers, sortBy,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

d3 = require('d3');

StackedBarChart = require('./stacked-bar');

helpers = require('./helpers');

EPSILON = 0.001;

get = function(key, from) {
  if (typeof key === 'function') {
    return key(from);
  } else {
    return from[key];
  }
};

sortBy = function(key, list) {
  return list.sort(function(a, b) {
    if (get(key, a) > get(key, b)) {
      return 1;
    } else if (get(key, a) < get(key, b)) {
      return -1;
    } else {
      return 0;
    }
  });
};

groupBy = function(key, list) {
  var grouped, i, item, len, value;
  grouped = {};
  sortBy(key, list);
  for (i = 0, len = list.length; i < len; i++) {
    item = list[i];
    value = get(key, item);
    grouped[value] || (grouped[value] = []);
    grouped[value].push(item);
  }
  return grouped;
};

module.exports = Histogram = (function(superClass) {
  extend(Histogram, superClass);

  function Histogram() {
    return Histogram.__super__.constructor.apply(this, arguments);
  }

  Histogram.prototype.getDefaultProps = function() {
    return {
      width: 100,
      height: 100,
      padding: 0,
      x_axis: {},
      y_axis: {}
    };
  };

  Histogram.prototype.binData = function() {
    var base, bin_key, bin_size, bins, data, group, group_key, group_value, grouped, i, in_edge_bin, item, j, len, max, min, n_bins, pointInRange, ref, results, x_extent;
    ref = this.props, data = ref.data, bin_key = ref.bin_key, min = ref.min, max = ref.max, n_bins = ref.n_bins, bin_size = ref.bin_size, group_key = ref.group_key;
    x_extent = d3.extent(data, function(d) {
      return d.x;
    });
    if (min != null) {
      x_extent[0] = min;
    } else {
      min = x_extent[0];
    }
    if (max != null) {
      x_extent[1] = max;
    } else {
      max = x_extent[1];
    }
    if (bin_size != null) {
      n_bins = Math.ceil((max - min) / bin_size);
    } else {
      n_bins || (n_bins = 10);
      bin_size = (max - min) / n_bins;
    }
    pointInRange = function(min, max) {
      return function(d) {
        var point;
        if (bin_key != null) {
          point = d[bin_key];
        } else {
          point = d;
        }
        return (point.x >= min) && (point.x < max);
      };
    };
    bins = (function() {
      results = [];
      for (var i = 0; 0 <= n_bins ? i < n_bins : i > n_bins; 0 <= n_bins ? i++ : i--){ results.push(i); }
      return results;
    }).apply(this).map(function(bi) {
      var b_max, b_min, grouped, in_this_bin;
      b_min = min + (bi * bin_size);
      b_max = min + ((bi + 1) * bin_size);
      in_this_bin = data.filter(pointInRange(b_min, b_max));
      grouped = groupBy(group_key, in_this_bin);
      return {
        x0: b_min,
        x: b_min,
        x1: b_max,
        grouped: grouped
      };
    });
    in_edge_bin = data.filter(pointInRange(max, max + EPSILON));
    grouped = groupBy(group_key, in_edge_bin);
    for (group_value in grouped) {
      group = grouped[group_value];
      for (j = 0, len = group.length; j < len; j++) {
        item = group[j];
        (base = bins[n_bins - 1].grouped)[group_value] || (base[group_value] = []);
        bins[n_bins - 1].grouped[group_value].push(item);
      }
    }
    return [bins, x_extent, n_bins];
  };

  Histogram.prototype.render = function() {
    var axis_size, bin, bins, color, data, data_by_group, datas, group, group_value, height, i, len, n_bins, onClick, padding, r, ref, ref1, ref2, title, total, width, x, x_axis, x_extent, y, y_axis, y_max;
    ref = this.props, width = ref.width, height = ref.height, padding = ref.padding, data = ref.data, x = ref.x, y = ref.y, r = ref.r, axis_size = ref.axis_size, title = ref.title, x_axis = ref.x_axis, y_axis = ref.y_axis, color = ref.color, onClick = ref.onClick;
    padding = helpers.transformPadding(padding);
    ref1 = this.binData(), bins = ref1[0], x_extent = ref1[1], n_bins = ref1[2];
    data_by_group = {};
    y_max = 0;
    for (i = 0, len = bins.length; i < len; i++) {
      bin = bins[i];
      total = 0;
      ref2 = bin.grouped;
      for (group_value in ref2) {
        group = ref2[group_value];
        data_by_group[group_value] || (data_by_group[group_value] = []);
        group.y0 = total;
        group.y = group.length;
        group.y1 = group.y0 + group.y;
        total += group.y;
        data_by_group[group_value].push({
          x: bin.x,
          x0: bin.x0,
          x1: bin.x1,
          y0: group.y0,
          y1: group.y1
        });
      }
      if (total > y_max) {
        y_max = total;
      }
    }
    datas = [];
    for (group_value in data_by_group) {
      data = data_by_group[group_value];
      data.key = group_value;
      datas.push(data);
    }
    x_axis.ticks || (x_axis.ticks = n_bins);
    x = d3.scaleLinear().domain(x_extent).range([padding.left, width - padding.right]);
    y = d3.scaleLinear().domain([0, y_max]).range([height - padding.bottom, padding.top]);
    return React.createElement(StackedBarChart, Object.assign({}, this.props, {
      "data": bins,
      "x": x,
      "y": y,
      "bar_width": (width - padding.left - padding.right) / n_bins - 1
    }));
  };

  return Histogram;

})(React.Component);
