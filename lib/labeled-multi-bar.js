// Generated by CoffeeScript 1.8.0
var Chart, EL_PADDING, LabeledMultiBarChart, React, add, d3, sum,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

React = require('react');

d3 = require('d3');

Chart = require('./chart');

add = function(a, b) {
  return a + b;
};

sum = function(numbers) {
  return numbers.reduce(add, 0);
};

EL_PADDING = 10;

module.exports = LabeledMultiBarChart = (function(_super) {
  __extends(LabeledMultiBarChart, _super);

  function LabeledMultiBarChart() {
    return LabeledMultiBarChart.__super__.constructor.apply(this, arguments);
  }

  LabeledMultiBarChart.prototype.chartHeight = function() {
    var height, label_height, max_label_length, rotate, _ref, _ref1, _ref2;
    if (rotate = (_ref = this.props.x_axis) != null ? _ref.rotate : void 0) {
      max_label_length = 0;
      this.props.data.forEach(function(d) {
        var _ref1;
        if ((d != null ? (_ref1 = d.label) != null ? _ref1.length : void 0 : void 0) > max_label_length) {
          return max_label_length = d.label.length;
        }
      });
      label_height = max_label_length * 6.5 * Math.sin(Math.PI * Math.abs(rotate) / 180);
    } else {
      label_height = 8;
    }
    height = this.props.height + (((_ref1 = this.props) != null ? (_ref2 = _ref1.options) != null ? _ref2.el_padding : void 0 : void 0) || 0) + 15 + label_height;
    return height;
  };

  LabeledMultiBarChart.prototype.renderChart = function() {
    var all_ys, bar_padding, bar_width, cell_index, cell_width, chart_height, colorer, colors, data, el_padding, height, horizontal, markers, num_bars, options, rotate_labels, spread, total_ys, width, x, x_extent, y, y_extent, y_max, _ref, _ref1, _ref2;
    _ref = this.props, width = _ref.width, height = _ref.height, data = _ref.data, x = _ref.x, y = _ref.y, colors = _ref.colors, options = _ref.options, markers = _ref.markers, colorer = _ref.colorer;
    _ref1 = this.state, x = _ref1.x, y = _ref1.y;
    bar_padding = options.bar_padding, bar_width = options.bar_width, spread = options.spread, horizontal = options.horizontal, el_padding = options.el_padding;
    bar_padding || (bar_padding = 10);
    el_padding || (el_padding = EL_PADDING);
    rotate_labels = (_ref2 = this.props.x_axis) != null ? _ref2.rotate : void 0;
    if (!spread) {
      num_bars = data.length;
      x_extent = d3.extent([0, width]);
      if (horizontal) {
        cell_width = Math.floor(height / num_bars - 1);
      } else {
        cell_width = Math.floor(width / num_bars - 1);
      }
      total_ys = data.map(function(d) {
        return sum(Object.keys(d.values).map(function(k) {
          return d.values[k];
        }));
      });
      y_extent = Math.max.apply(Math, total_ys);
      y = d3.scaleLinear().domain([0, y_extent]).range([0, height]);
      cell_index = -1;
      chart_height = height + 4 * bar_padding;
      return React.createElement("svg", {
        "className": 'bar-chart',
        "style": {
          width: width,
          height: chart_height
        },
        "width": width,
        "height": chart_height
      }, data.map((function(_this) {
        return function(d, i_data) {
          var l, label_height, label_x, label_x_tmp, label_y, label_y_tmp, text_anchor, total_y;
          cell_index++;
          total_y = 0;
          return React.createElement("g", {
            "className": 'bar',
            "key": i_data
          }, (l = d.label, label_height = 8, label_x = cell_width * (i_data + 0.5), label_y = height + 15 + el_padding, rotate_labels > 0 ? (text_anchor = 'start', label_x -= label_height / 2) : rotate_labels < 0 ? (text_anchor = 'end', label_x += label_height / 2) : text_anchor = 'middle', horizontal ? (label_y_tmp = label_y, label_x_tmp = label_x, label_x = 0, label_y = label_x_tmp) : void 0, React.createElement("text", {
            "className": 'label',
            "y": label_y,
            "x": label_x,
            "textAnchor": text_anchor,
            "width": cell_width,
            "transform": "rotate(" + rotate_labels + "," + label_x + "," + label_y + ")"
          }, l)), Object.keys(d.values).map(function(segment_key) {
            var left_padding, offset_left, offset_top, renderBar, segment_color, segment_height, segment_width, tmp, value, x_pos, y_pos, _ref3, _ref4;
            value = d.values[segment_key];
            total_y = total_y + value;
            segment_color = (typeof colorer === "function" ? colorer(segment_key) : void 0) || d.color || (colors != null ? colors[segment_key] : void 0) || "#333";
            segment_width = bar_width || (cell_width - bar_padding);
            segment_height = y(value);
            left_padding = (cell_width - segment_width) / 2;
            y_pos = height - y(total_y);
            x_pos = left_padding + cell_width * cell_index;
            if (horizontal) {
              tmp = {};
              tmp.height = segment_height;
              tmp.y_pos = y_pos;
              segment_height = segment_width;
              segment_width = tmp.height;
              y_pos = x_pos;
              x_pos = y(total_y) - segment_width;
            }
            renderBar = function() {
              return React.createElement("rect", {
                "key": i_data + '.' + segment_key,
                "y": y_pos,
                "x": x_pos,
                "width": segment_width,
                "height": segment_height,
                "fill": segment_color
              }, React.createElement("title", null, value));
            };
            if ((options.display_values != null) && value > 0) {
              offset_left = options.display_values.offset_left || 0;
              offset_top = options.display_values.offset_top || 3;
              if (offset_left > 0) {
                text_anchor = 'left';
                label_x = x_pos + offset_left;
              } else {
                text_anchor = 'middle';
                label_x = x_pos + segment_width / 2;
              }
              return React.createElement("g", {
                "x": x_pos,
                "y": y_pos,
                "style": {
                  height: segment_height,
                  width: segment_width
                }
              }, renderBar(), React.createElement("text", {
                "className": 'value-label',
                "textAnchor": text_anchor,
                "alignmentBaseline": 'hanging',
                "x": label_x,
                "y": y_pos + offset_top
              }, (((_ref3 = options.display_values) != null ? _ref3.display : void 0) ? (_ref4 = options.display_values) != null ? _ref4.display(value) : void 0 : value)));
            } else {
              return renderBar();
            }
          }));
        };
      })(this)));
    } else {
      num_bars = 0;
      y_max = 0;
      bar_padding || (bar_padding = 1);
      all_ys = data.map(function(d) {
        return Object.keys(d.values).map(function(k) {
          var value;
          num_bars++;
          value = d.values[k];
          if (y_max < value) {
            y_max = value;
          }
          return value;
        });
      });
      markers.forEach(function(marker) {
        if (y_max < marker.value) {
          return y_max = marker.value;
        }
      });
      num_bars += data.length - 1;
      x_extent = d3.extent([0, width]);
      if (horizontal) {
        cell_width = Math.floor(height / num_bars - 1);
      } else {
        cell_width = Math.floor(width / num_bars - 1);
      }
      if (this.props.y_axis.domain != null) {
        y_max = this.props.y_axis.domain[1];
      }
      y = d3.scaleLinear().domain([0, y_max]).range([0, height]);
      cell_index = -1;
      chart_height = height + 4 * bar_padding;
      return React.createElement("svg", {
        "className": 'bar-chart',
        "style": {
          width: width,
          height: chart_height
        },
        "width": width,
        "height": chart_height
      }, data.map((function(_this) {
        return function(d, i_data) {
          var cell_markers, family_width, l, label_height, label_x, label_x_tmp, label_y, label_y_tmp, text_anchor, total_y;
          total_y = 0;
          cell_index++;
          cell_markers = markers != null ? markers.filter(function(m) {
            return m.cell_key === d.cell_key;
          }) : void 0;
          family_width = cell_width * (Object.keys(d.values).length + 1);
          return React.createElement("g", {
            "className": 'bar',
            "key": i_data
          }, (l = d.label, label_height = 8, label_x = family_width * (i_data + 0.5) - cell_width / 2, label_y = height + 15 + el_padding, rotate_labels > 0 ? (text_anchor = 'start', label_x -= label_height / 2) : rotate_labels < 0 ? (text_anchor = 'end', label_x += label_height / 2) : text_anchor = 'middle', horizontal ? (label_y_tmp = label_y, label_x_tmp = label_x, label_x = 0, label_y = label_x_tmp) : void 0, React.createElement("text", {
            "className": 'label',
            "y": label_y,
            "x": label_x,
            "textAnchor": text_anchor,
            "width": cell_width,
            "transform": "rotate(" + rotate_labels + "," + label_x + "," + label_y + ")"
          }, l)), Object.keys(d.values).map(function(segment_key) {
            var left_padding, offset_left, offset_top, renderBar, segment_color, segment_height, segment_width, tmp, value, x_pos, y_pos, _ref3, _ref4;
            value = d.values[segment_key];
            total_y = total_y + value;
            segment_width = bar_width || (cell_width - bar_padding);
            segment_color = (typeof colorer === "function" ? colorer(segment_key) : void 0) || d.color || (colors != null ? colors[segment_key] : void 0) || "#333";
            segment_height = y(value);
            left_padding = (cell_width + (cell_width - segment_width)) / 2;
            x_pos = left_padding + cell_width * cell_index - cell_width / 2;
            y_pos = height - y(value);
            if (horizontal) {
              tmp = {};
              tmp.height = segment_height;
              tmp.y_pos = y_pos;
              segment_height = segment_width;
              segment_width = tmp.height;
              y_pos = x_pos;
              x_pos = 0;
            }
            cell_index++;
            renderBar = function() {
              return React.createElement("rect", {
                "key": i_data + '.' + segment_key,
                "y": y_pos,
                "x": x_pos,
                "width": segment_width,
                "height": segment_height,
                "fill": segment_color
              }, React.createElement("title", null, value));
            };
            if ((options.display_values != null) && value > 0) {
              offset_left = options.display_values.offset_left || 0;
              offset_top = options.display_values.offset_top || 3;
              if (offset_left > 0) {
                text_anchor = 'left';
                label_x = x_pos + offset_left;
              } else {
                text_anchor = 'middle';
                label_x = x_pos + segment_width / 2;
              }
              return React.createElement("g", {
                "x": x_pos,
                "y": y_pos,
                "style": {
                  height: segment_height,
                  width: segment_width
                }
              }, renderBar(), React.createElement("text", {
                "className": 'value-label',
                "textAnchor": text_anchor,
                "alignmentBaseline": 'hanging',
                "x": label_x,
                "y": y_pos + offset_top
              }, (((_ref3 = options.display_values) != null ? _ref3.display : void 0) ? (_ref4 = options.display_values) != null ? _ref4.display(value) : void 0 : value)));
            } else {
              return renderBar();
            }
          }), cell_markers != null ? cell_markers.map(function(marker, i) {
            var symbol_generator;
            if (marker.kind === 'diamond') {
              symbol_generator = d3.symbol().type(d3.symbolDiamond).size(80);
              return React.createElement("path", {
                "className": 'dot',
                "key": i,
                "d": symbol_generator(),
                "transform": "translate(" + (family_width * (i_data + 0.5) - cell_width / 2) + "," + (y(y_max - marker.value)) + ")",
                "fill": (colors != null ? colors[marker.series_key] : void 0) || "#333"
              }, React.createElement("title", null, marker.value));
            } else {
              return React.createElement("circle", {
                "className": 'dot',
                "key": i,
                "r": 4,
                "cx": cell_width * (cell_index - 0.5) - cell_width / 2,
                "cy": y(marker.value),
                "fill": (colors != null ? colors[marker.series_key] : void 0) || "#333"
              }, React.createElement("title", null, marker.value));
            }
          }) : void 0);
        };
      })(this)));
    }
  };

  return LabeledMultiBarChart;

})(Chart);
