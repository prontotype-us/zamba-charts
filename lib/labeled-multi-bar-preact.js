// Generated by CoffeeScript 1.10.0
var LabeledMultiBarChart, React, add, d3, sum,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('preact');

d3 = require('d3');

add = function(a, b) {
  return a + b;
};

sum = function(numbers) {
  return numbers.reduce(add, 0);
};

module.exports = LabeledMultiBarChart = (function(superClass) {
  extend(LabeledMultiBarChart, superClass);

  function LabeledMultiBarChart() {
    return LabeledMultiBarChart.__super__.constructor.apply(this, arguments);
  }

  LabeledMultiBarChart.prototype.render = function() {
    var all_ys, bar_padding, bar_width, cell_index, cell_width, chart_height, colorer, colors, data, height, horizontal, markers, num_bars, options, ref, spread, total_ys, width, x, x_extent, y, y_extent, y_max;
    ref = this.props, width = ref.width, height = ref.height, data = ref.data, x = ref.x, y = ref.y, colors = ref.colors, options = ref.options, markers = ref.markers, colorer = ref.colorer;
    bar_padding = options.bar_padding, bar_width = options.bar_width, spread = options.spread, horizontal = options.horizontal;
    bar_padding || (bar_padding = 10);
    if (!spread) {
      num_bars = data.length;
      x_extent = d3.extent([0, width]);
      cell_width = Math.floor(width / num_bars - 1);
      total_ys = data.map(function(d) {
        return sum(Object.keys(d.values).map(function(k) {
          return d.values[k];
        }));
      });
      y_extent = Math.max.apply(Math, total_ys);
      y = d3.scaleLinear().domain([0, y_extent]).range([0, height]);
      cell_index = -1;
      chart_height = height + 4 * bar_padding;
      return React.createElement("svg", {
        "className": 'bar-chart',
        "style": {
          width: width,
          height: chart_height
        }
      }, data.map((function(_this) {
        return function(d, i_data) {
          var ref1, total_y;
          cell_index++;
          total_y = 0;
          return React.createElement("g", {
            "className": 'bar',
            "key": i_data
          }, (ref1 = d.label) != null ? ref1.split(' ').map(function(l, i_label) {
            var label_width, label_x, label_x_tmp, label_y, label_y_tmp;
            label_width = 6.5 * l.length;
            label_x = cell_width * (i_data + 0.5) - label_width / 2;
            label_y = height + (15 * (i_label + 1));
            if (horizontal) {
              label_y_tmp = label_y;
              label_x_tmp = label_x;
              label_x = label_y;
              label_y = label_x_tmp;
            }
            return React.createElement("text", {
              "className": 'label',
              "y": label_y,
              "x": label_x,
              "width": cell_width
            }, l);
          }) : void 0, Object.keys(d.values).map(function(segment_key) {
            var left_padding, segment_color, segment_height, segment_width, tmp, value, x_pos, y_pos;
            value = d.values[segment_key];
            total_y = total_y + value;
            segment_color = (typeof colorer === "function" ? colorer(segment_key) : void 0) || d.color || (colors != null ? colors[segment_key] : void 0) || "#333";
            segment_width = bar_width || (cell_width - bar_padding);
            segment_height = y(value);
            left_padding = (cell_width - segment_width) / 2;
            y_pos = height - y(total_y);
            x_pos = left_padding + cell_width * cell_index;
            if (horizontal) {
              tmp = {};
              tmp.height = segment_height;
              tmp.y_pos = y_pos;
              segment_height = segment_width;
              segment_width = tmp.height;
              y_pos = x_pos;
              x_pos = tmp.y_pos;
            }
            return React.createElement("rect", {
              "key": i_data + '.' + segment_key,
              "y": y_pos,
              "x": x_pos,
              "width": segment_width,
              "height": segment_height,
              "fill": segment_color
            });
          }));
        };
      })(this)));
    } else {
      num_bars = 0;
      y_max = 0;
      bar_padding || (bar_padding = 1);
      all_ys = data.map(function(d) {
        return Object.keys(d.values).map(function(k) {
          var value;
          num_bars++;
          value = d.values[k];
          if (y_max < value) {
            y_max = value;
          }
          return value;
        });
      });
      num_bars += data.length - 1;
      x_extent = d3.extent([0, width]);
      cell_width = Math.floor(width / num_bars - 1);
      y = d3.scaleLinear().domain([0, y_max]).range([0, height]);
      cell_index = -1;
      chart_height = height + 4 * bar_padding;
      return React.createElement("svg", {
        "className": 'bar-chart',
        "style": {
          width: width,
          height: chart_height
        }
      }, data.map((function(_this) {
        return function(d, i_data) {
          var cell_markers, family_width, ref1, total_y;
          total_y = 0;
          cell_index++;
          cell_markers = markers != null ? markers.filter(function(m) {
            return m.cell_key === d.cell_key;
          }) : void 0;
          family_width = cell_width * (Object.keys(d.values).length + 1);
          return React.createElement("g", {
            "className": 'bar',
            "key": i_data
          }, (ref1 = d.label) != null ? ref1.split(' ').map(function(l, i_label) {
            var label_width, label_x, label_x_tmp, label_y, label_y_tmp;
            label_width = 6 * l.length;
            label_x = family_width * (i_data + 0.5) - label_width / 2;
            label_y = height + bar_padding + (15 * (i_label + 1));
            if (horizontal) {
              label_y_tmp = label_y;
              label_x_tmp = label_x;
              label_x = label_y;
              label_y = label_x_tmp;
            }
            return React.createElement("text", {
              "className": 'label',
              "y": label_y,
              "x": label_x,
              "width": cell_width
            }, l);
          }) : void 0, Object.keys(d.values).map(function(segment_key) {
            var left_padding, segment_color, segment_height, segment_width, tmp, value, x_pos, y_pos;
            value = d.values[segment_key];
            total_y = total_y + value;
            segment_color = (typeof colorer === "function" ? colorer(segment_key) : void 0) || d.color || (colors != null ? colors[segment_key] : void 0) || "#333";
            segment_width = bar_width || (cell_width - bar_padding);
            segment_height = y(value);
            left_padding = (cell_width + (cell_width - segment_width)) / 2;
            x_pos = left_padding + cell_width * cell_index;
            y_pos = height - y(value);
            if (horizontal) {
              tmp = {};
              tmp.height = segment_height;
              tmp.y_pos = y_pos;
              segment_height = segment_width;
              segment_width = tmp.height;
              y_pos = x_pos;
              x_pos = tmp.y_pos;
            }
            cell_index++;
            return React.createElement("rect", {
              "key": i_data + '.' + segment_key,
              "y": y_pos,
              "x": x_pos,
              "width": segment_width,
              "height": segment_height,
              "fill": segment_color
            });
          }), cell_markers != null ? cell_markers.map(function(marker, i) {
            var symbol_generator;
            if (marker.kind === 'diamond') {
              symbol_generator = d3.symbol().type(d3.symbolDiamond).size(80);
              return React.createElement("path", {
                "className": 'dot',
                "key": i,
                "d": symbol_generator(),
                "transform": "translate(" + (family_width * (i_data + 0.5)) + "," + (y(y_max - marker.value)) + ")",
                "fill": (colors != null ? colors[marker.series_key] : void 0) || "#333"
              });
            } else {
              return React.createElement("circle", {
                "className": 'dot',
                "key": i,
                "r": 4,
                "cx": cell_width * (cell_index - 0.5),
                "cy": y(marker.value),
                "fill": (colors != null ? colors[marker.series_key] : void 0) || "#333"
              });
            }
          }) : void 0);
        };
      })(this)));
    }
  };

  return LabeledMultiBarChart;

})(React.Component);
